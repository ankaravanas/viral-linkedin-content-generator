#!/usr/bin/env python3
"""LinkedIn Viral Content Generator MCP Server"""

import os
import requests
import re
import time
from typing import Dict, List
from pathlib import Path
from fastmcp import FastMCP
from dotenv import load_dotenv

load_dotenv()
mcp = FastMCP("LinkedIn Content Generator")

# Simple state
state = {}

def apify(actor: str, data: dict) -> dict:
    """Call Apify actor with proper API format"""
    token = os.getenv("APIFY_TOKEN")
    if not token or token == "your_apify_token_here":
        return {"error": "Please set your real APIFY_TOKEN in .env file"}
    
    # Use FAST synchronous endpoint - no polling, immediate results
    sync_url = f"https://api.apify.com/v2/acts/{actor}/run-sync-get-dataset-items"
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
    
    try:
        # This endpoint runs the actor and returns results immediately
        response = requests.post(sync_url, json=data, headers=headers, timeout=60)
        
        if response.ok:
            return {"data": response.json()}
        else:
            return {"error": f"Actor failed {response.status_code}: {response.text[:200]}"}
        
    except Exception as e:
        return {"error": str(e)}

@mcp.tool()
def start_discovery(niche: str, platform: str) -> str:
    """
    Start the LinkedIn viral content generation workflow with conversational guidance.
    
    Args:
        niche: Your content niche (e.g., "AI automation", "SaaS marketing", "productivity systems")
        platform: Platform to research ("youtube", "tiktok", "instagram", "linkedin")
    """
    state["niche"] = niche
    state["platform"] = platform.lower()
    state["content"] = []
    state["selected"] = None
    state["analysis"] = {}
    
    return f"""I can help you create viral LinkedIn lead magnet posts based on what's working on {platform} in your niche.

âœ… Starting content discovery for: '{niche}' on {platform}

I'll search for high-performing content in the {niche} space, analyze what makes it viral, extract key insights, and help you create LinkedIn posts that convert.

Ready to discover viral content? I'll search {platform} and present you with the top-performing content to choose from.

Would you like me to proceed with finding viral {niche} content on {platform}?"""

@mcp.tool()
def youtube(query: str) -> dict:
    """
    Discover YouTube videos for content analysis.
    Analyzes videos based on view count, engagement, and viral patterns.
    """
    result = apify("streamers~youtube-scraper", {
        "searchQueries": [query],
        "maxResults": 5,
        "downloadSubtitles": True,
        "preferAutoGeneratedSubtitles": True,
        "saveSubsToKVS": True,
        "maxResultStreams": 0,
        "maxResultsShorts": 0
    })
    
    if "data" in result:
        state["content"] = result["data"][:5]
        
        # Present top 5 videos with key metrics for selection
        videos = []
        for i, video in enumerate(state["content"], 1):
            videos.append({
                "index": i,
                "title": video.get("title", "No title"),
                "author": video.get("channelName", "Unknown"),
                "views": video.get("viewCount", 0),
                "duration": video.get("duration", "Unknown"),
                "url": video.get("url", "")
            })
        
        return {
            "status": "success",
            "message": f"Found {len(videos)} YouTube videos in the {state.get('niche', 'your')} space:",
            "videos": videos,
            "guidance": "I've analyzed these videos for viral potential. Look for high view counts, strong engagement, and compelling titles with numbers or contrarian viewpoints.",
            "next_question": "Which of these videos would you like me to analyze further for your LinkedIn content? Please tell me the index number (1-5)."
        }
    
    return result

@mcp.tool()
def tiktok(hashtag: str) -> dict:
    """
    Discover TikTok videos for content analysis.
    Focuses on high engagement rate and viral patterns (15-60 second videos).
    """
    result = apify("clockworks~tiktok-scraper", {
        "hashtags": [hashtag],
        "resultsPerPage": 15,
        "shouldDownloadCovers": False,
        "shouldDownloadSlideshowImages": False,
        "shouldDownloadSubtitles": True,
        "shouldDownloadVideos": False,
        "proxyCountryCode": "None"
    })
    
    if "data" in result:
        state["content"] = result["data"][:5]
        
        # Present top 5 videos prioritizing engagement rate
        videos = []
        for i, video in enumerate(state["content"], 1):
            plays = video.get("playCount", 0)
            likes = video.get("diggCount", 0)
            comments = video.get("commentCount", 0)
            engagement_rate = ((likes + comments) / plays * 100) if plays > 0 else 0
            
            videos.append({
                "index": i,
                "text": video.get("text", "No description"),
                "author": video.get("authorMeta", {}).get("name", "Unknown"),
                "plays": plays,
                "likes": likes,
                "comments": comments,
                "engagement_rate": round(engagement_rate, 2),
                "url": video.get("webVideoUrl", "")
            })
        
        # Sort by engagement rate for viral potential
        videos.sort(key=lambda x: x["engagement_rate"], reverse=True)
        
        return {
            "status": "success",
            "message": f"Found {len(videos)} TikTok videos (sorted by engagement rate for viral potential):",
            "videos": videos,
            "next_step": "Which of these videos would you like to analyze further for your LinkedIn content? Use select(index)."
        }
    
    return result

@mcp.tool()
def instagram(username: str) -> dict:
    """Scrape Instagram"""
    result = apify("apify~instagram-scraper", {"usernames": [username], "resultsLimit": 10})
    if "data" in result:
        state["content"] = result["data"][:5]
        return {"posts": [{"i": i+1, "caption": p.get("caption", "")[:50], "likes": p.get("likesCount", 0)} 
                         for i, p in enumerate(state["content"])]}
    return result

@mcp.tool()
def linkedin(profile_url: str) -> dict:
    """Scrape LinkedIn"""
    result = apify("apimaestro~linkedin-profile-posts", {"profileUrl": profile_url})
    if "data" in result:
        state["content"] = result["data"][:5]
        return {"posts": [{"i": i+1, "text": p.get("text", "")[:50], "likes": p.get("numLikes", 0)} 
                         for i, p in enumerate(state["content"])]}
    return result

@mcp.tool()
def select(index: int) -> str:
    """
    Select content for detailed analysis.
    Provides conversational feedback about the selection.
    """
    if "content" not in state or not state["content"]:
        return "I haven't found any content yet. Please use youtube(), tiktok(), instagram(), or linkedin() first to discover content."
    
    if index < 1 or index > len(state["content"]):
        return f"Please choose a valid index between 1 and {len(state['content'])}. Which video/post would you like me to analyze?"
    
    selected = state["content"][index - 1]
    state["selected"] = selected
    
    # Get content info for confirmation
    if state.get("platform") == "youtube":
        title = selected.get("title", "Unknown title")
        views = selected.get("viewCount", 0)
        return f"""Perfect! I've selected: "{title}" 

This video has {views:,} views, which shows strong viral potential.

Now I'll analyze this content to extract:
- Key quantitative metrics (percentages, ROI figures, timeframes)
- Core insights and frameworks
- Pattern interrupts and contrarian viewpoints

Ready for me to analyze this content for viral LinkedIn insights?"""
    
    elif state.get("platform") == "tiktok":
        text = selected.get("text", "")[:100]
        plays = selected.get("playCount", 0)
        return f"""Great choice! I've selected the TikTok video: "{text}..."

This video has {plays:,} plays with strong engagement signals.

I'll analyze this short-form content focusing on:
- Strong hooks and pattern interrupts (critical first 3 seconds)
- Controversial or counterintuitive takes
- Text overlays and captions for insights

Ready for the analysis?"""
    
    else:
        return f"âœ… Selected content {index}. Ready to analyze this for viral LinkedIn insights?"

@mcp.tool()
def analyze() -> dict:
    """
    Analyze selected content for viral insights and quantitative data.
    Extracts core message, frameworks, pattern interrupts, and key metrics.
    """
    if "selected" not in state:
        return {"error": "No content selected"}
    
    content = state["selected"]
    platform = state.get("platform", "")
    
    # Extract content text based on platform
    if platform == "youtube":
        text = content.get("subtitles", "") or content.get("title", "") + " " + content.get("description", "")
    elif platform == "tiktok":
        text = content.get("text", "")  # TikTok text field contains description/caption
    elif platform == "instagram":
        text = content.get("caption", "")
    elif platform == "linkedin":
        text = content.get("text", "")
    else:
        text = content.get("title", "") + " " + content.get("text", "") + " " + content.get("description", "")
    
    # Extract quantitative metrics (percentages, ROI, timeframes, growth)
    metrics = []
    metrics.extend(re.findall(r'\b\d+%', text))  # Percentages
    metrics.extend(re.findall(r'\$[\d,]+(?:\.\d{2})?', text))  # Dollar amounts
    metrics.extend(re.findall(r'\b\d+[xX]', text))  # Multipliers (2x, 10x)
    metrics.extend(re.findall(r'\b\d+\s*(?:days?|weeks?|months?|years?)', text))  # Timeframes
    metrics.extend(re.findall(r'\b\d+%\s*(?:increase|growth|boost|conversion|roi)', text, re.IGNORECASE))  # Growth metrics
    
    # Extract core insights
    sentences = [s.strip() for s in text.split('.') if len(s.strip()) > 20]
    core_message = sentences[0] if sentences else ""
    
    # Look for pattern interrupts (counterintuitive statements)
    interrupts = []
    interrupt_phrases = ["but here's the thing", "however", "the truth is", "what most people don't know", "contrary to"]
    for sentence in sentences:
        if any(phrase in sentence.lower() for phrase in interrupt_phrases):
            interrupts.append(sentence.strip())
    
    # Focus on most impactful 2-3 data points
    top_metrics = list(set(metrics))[:3]
    
    analysis = {
        "quantitative_metrics": top_metrics,
        "core_message": core_message[:200],
        "pattern_interrupts": interrupts[:2],
        "text_length": len(text),
        "platform": platform
    }
    
    state["analysis"] = analysis
    
    return {
        "status": "success",
        "analysis": analysis,
        "next_step": "Use comments() to analyze engagement patterns, or proceed to ideas() for content generation."
    }

@mcp.tool()
def comments() -> dict:
    """
    Analyze comments for the selected content.
    Extracts pain points, questions, and sentiment distribution.
    """
    if "selected" not in state:
        return {"error": "No content selected"}
    
    content = state["selected"]
    platform = state.get("platform", "")
    url = content.get("url") or content.get("webVideoUrl", "")
    
    if not url:
        return {"error": "No URL found for comment analysis"}
    
    # Scrape comments based on platform
    if platform == "youtube":
        result = apify("streamers~youtube-comments-scraper", {"videoURLs": [url]})
    elif platform == "tiktok":
        result = apify("clockworks~tiktok-comments-scraper", {"postURLs": [url], "commentsPerPost": 100})
    elif platform == "instagram":
        result = apify("apify~instagram-comment-scraper", {"postUrls": [url]})
    elif platform == "linkedin":
        result = apify("apimaestro~linkedin-post-comments-replies-engagements-scraper-no-cookies", {"postUrls": [url]})
    else:
        return {"error": f"Comments not supported for {platform}"}
    
    if "data" in result:
        comments = result["data"]
        
        # Extract pain points and questions
        pain_points = []
        questions = []
        texts = [c.get("text", "") or c.get("comment", "") for c in comments if c.get("text") or c.get("comment")]
        
        for text in texts[:50]:  # Analyze first 50 comments
            text_lower = text.lower()
            if any(word in text_lower for word in ["problem", "issue", "difficult", "struggle", "can't"]):
                pain_points.append(text[:100])
            if any(word in text_lower for word in ["how", "what", "why"]) and "?" in text:
                questions.append(text[:100])
        
        comment_analysis = {
            "total_comments": len(comments),
            "pain_points": pain_points[:3],
            "common_questions": questions[:3],
            "sentiment": "analyzed" if comments else "no_comments"
        }
        
        state["comment_analysis"] = comment_analysis
        return {
            "status": "success",
            "comment_analysis": comment_analysis,
            "next_step": "Use ideas() to generate content concepts based on analysis."
        }
    
    return result

@mcp.tool()
def ideas() -> dict:
    """
    Generate SHORT content ideas (40-60 words) using hook frameworks.
    Creates concise concepts with quantitative data points.
    """
    if "analysis" not in state:
        return {"error": "No content analysis available"}
    
    niche = state.get("niche", "your topic")
    analysis = state["analysis"]
    metrics = analysis.get("quantitative_metrics", [])
    core_message = analysis.get("core_message", "")
    
    # Generate SHORT content ideas (40-60 words max)
    ideas = []
    
    # Idea 1: Metric-based hook
    if metrics:
        metric = metrics[0]
        ideas.append(f"The #1 mistake I see with {niche}? {metric} of people focus on the wrong approach. After analyzing viral content, I discovered the real opportunity lies in strategic execution.")
    
    # Idea 2: Pattern interrupt hook  
    if core_message:
        ideas.append(f"Unpopular opinion about {niche}: {core_message[:60]}... This changes everything.")
    
    # Idea 3: Authority hook
    platform = state.get("platform", "content")
    ideas.append(f"After analyzing viral {platform} content, I discovered the #{1} {niche} secret that nobody talks about.")
    
    # Keep ideas SHORT (40-60 words)
    state["ideas"] = [idea[:200] for idea in ideas[:3]]
    
    return {
        "status": "success", 
        "ideas": state["ideas"],
        "message": "Generated SHORT content ideas (40-60 words each)",
        "next_step": "Use posts(idea_index) to create full LinkedIn posts from selected idea."
    }

@mcp.tool()
def posts(idea_index: int = 1) -> dict:
    """
    Transform SHORT content idea into 3 full LinkedIn posts without emojis.
    Uses hook templates and proven copywriting formulas.
    """
    if "ideas" not in state:
        return {"error": "No content ideas available"}
    
    if idea_index < 1 or idea_index > len(state["ideas"]):
        idea_index = 1
    
    selected_idea = state["ideas"][idea_index - 1]
    niche = state.get("niche", "your topic")
    platform = state.get("platform", "content")
    analysis = state.get("analysis", {})
    metrics = analysis.get("quantitative_metrics", [])
    
    # Post 1: Problem-Solution format (AIDA framework)
    post1 = f"""{selected_idea}

After analyzing {platform} content in the {niche} space, here's what I found:

The data shows most people focus on quantity over quality.

But top performers prioritize strategic insights over tactical execution.

The difference? They understand that sustainable growth comes from consistent value delivery.

What's your experience with {niche}?"""

    # Post 2: Story-lesson format
    metric_text = f"Key insight: {metrics[0]}" if metrics else "The approach that works is often counterintuitive"
    
    post2 = f"""Last week, I dove deep into {niche} content analysis.

The results were eye-opening.

{metric_text}

But here's what surprised me most: {selected_idea.split('?')[1] if '?' in selected_idea else 'Success comes from focus, not features'}

This completely changed how I think about {niche}.

Are you making this same mistake?"""

    # Post 3: Contrarian take
    post3 = f"""Unpopular opinion: {selected_idea}

Everyone talks about best practices in {niche}, but nobody mentions:

â€¢ Quality beats quantity every single time
â€¢ Authentic stories outperform generic tips  
â€¢ Engagement comes from genuine value, not tricks

The data doesn't lie. Are you ready to try a different approach?

What's worked for you in {niche}?"""

    posts = [post1, post2, post3]
    state["posts"] = posts
    
    return {
        "status": "success",
        "posts": posts,
        "selected_idea": selected_idea,
        "message": "Generated 3 LinkedIn posts ready to publish (no emojis, proper formatting)"
    }

@mcp.tool()
def status() -> dict:
    """Get status"""
    return {
        "niche": state.get("niche"),
        "platform": state.get("platform"),
        "content_count": len(state.get("content", [])),
        "selected": bool(state.get("selected")),
        "analyzed": bool(state.get("analysis")),
        "ideas": len(state.get("ideas", [])),
        "posts": len(state.get("posts", [])),
        "apify": bool(os.getenv("APIFY_TOKEN"))
    }

if __name__ == "__main__":
    port = os.getenv("PORT")
    
    if port:
        # Railway deployment - HTTP transport
        print(f"ğŸŒ Railway mode: HTTP transport on port {port}")
        mcp.run(transport="http", host="0.0.0.0", port=int(port))
    else:
        # Local development - stdio transport  
        print("ğŸ”— Local mode: stdio transport")
        mcp.run()